# Service

> 서비스는 어플리케이션의 구성요소이다. 하지만 백그라운드에서 작업을 수행하여 다른 어플리케이션에서도 서비스를 시작할 수 있고 어플리케이션이 전환 되더라도 작업이 백그라운드 작업이 계속 실행된다. 예를 들면 네트워크 트랜잭션 또는 음악재생등을 백그라운드에서 수행할 수 있다.



## 서비스 유형

> 서비스는 총 3가지 유형이 이다.



**포그라운드**

포그라운드 서비스는 사용자에게 알림을 통해 보여야한다. 따라서 사용자에게 작업이 수행중인걸 계속 확인 시켜야하는 작업을 하면된다. 예를 들면 오디오 트랙을 재생할때 포그라운드 서비스를 사용하면 된다.



**백그라운드**

백그라운드 서비스는 사용자에게 직접 보이지 않는 작업을 수행한다. 하지만 API26 이상에서는 백그라운드 서비스 실행에 제한을 한다.



**바인드**

서비스를 바인딩을 하게되면 클라이언트-서버 인터페이스를 제공하여 구성 요소가 서비스와 상호작용하게 하며, 결과를 받을 수도 있고 심지어 이와 같은 작업을 여러 프로세스에 걸쳐 프로세스 간 통신을 수행 할 수도 있다. 바인드는 포그라운드와 백그라운드 처럼 별도로 나누는 개념은 아니고 양쪽 서비스에서 모두 작동될 수 있는 개념이다. 



## 기본사항

서비스를 생성하기 위해서는 `Service`의 하위 클래스를 생성해야한다. `Service`의 구현체를 만들기 위해서는 다음과 같은 콜백 메서드를 재정의 해야한다.



**`onStartCommand()`**

이 메서드는 액티비티등 다른 구성요소에서 해당 서비스를 시작하도록 요청할 때 호출 된다. 이는 `startService()`를 통해 호출하게 된다. 한번 실행된 서비스는 백그라운드에서 무한히 실행 될 수 있다.



**`onBind()`**

이 메서드는 다른 구성요소에서 서비스가 바인딩되기 직전에 호출된다. 이는 `bindService()`를 통해 호출하게 된다. 이때 클라이언트와 서비스를 통신할 수 있도록 인터페이스를 제공해야된다. 따라서 이때 `IBinder`를 반환하면 된다. 만약 바인딩을 허용하지 않으면 null을 반환하면된다.



**`onCreate()`**

이 메서드는 서비스가 처음 생성되었을 때 호출된다. 또한 일회성 호출로 설정 절차를 수행한다. 서비스가 이미 실행 중일 경우 호출되지 않는다.



**`onDestroy()`**

이 메서드는 서비스가 더 이상 사용되지 않고 소멸시킬 때 호출 된다. 따라서 스레드, 등록된 리스너, 리시버의 각종 리소스를 정리하게 된다. 이 메서드는 서비스가 수신하는 마지막 호출이다.



# 바인드된 서비스

> 바인드된 서비스란 클라이언트-서버 인터페이스 에서 서버를 말한다. 이는 컴포넌트를 서비스에 바이딩하고, 요청을 보내고, 응답을 수신하며, 프로세스 간 통신을 할 수 있게 한다. 또한 다른 어플리케이션의 컴포넌트에 서비스를 제공하는 동안에만 유지되고 백그라운드에서 무한히 돌지 않게 할 수 있다.



### 바인드된 서비스 생성

바인딩을 제공하는 서비스를 생성할 때는 클라이언트와 상호작용할 수 있는 프로그래밍 인터페이스인 `IBinder`라고 한다. 정의하는 방법은 총 세 가지가 있다.

#### 

##### 바인더 클래스 확장

서비스가 어플리케이션 전용으로 클라이언트와 같은 프로세스에서 실행될 경우 `Binder`클래스를 확장하는데 그 인스턴스는 `onBinder`에서 반환하는 방식으로 사용한다. 클라이언트는 `Binder`를 받고 이를 사용하여 서비스에 엑세스 하게 되는 것이다.



##### 메신저 사용

인터페이스가 여러 프로세스에서 작동해야 하는 경우, `Messenger`를 통해 서비스를 정의할 수 있다. 이는 `Handler` 를 통해 `Messenger`들의 유형마다의 응답을 정의 하여 사용할 수 있다. 또한 `IBinder`를 공유하고 이를 통해 `Messenger`를 전달하여 명령어를 보낼 수 있게 된다. 이는 프로세스 간 통신을 실행하는 가장 간단한 방법이다. 왜냐하면  `Messenger`가 모든 요청을 단일 스레드 큐에 저장하므로 서비스를 스레드로부터 안전하게 설계할 필요가 없기 때문이다.



##### AIDL 사용

AIDL은 객체를 운영체제가 이해할 수 있는 원시 유형으로 해체한 다음, 여러 프로세스에서 마샬링하여 IPC를 실행합니다. `Messenger`를 사용하는 이전 기법은 실제로 AIDL을 기본 구조로 하고 있습니다. `Messenger` 는 단일 스레드에 모든 클라이언트 요청 큐를 생성하므로 서비스는 한번에 하나씩 처리하도록 되어있다. 하지만 AIDL를 직접 사용하여 서비스가 동시에 여러 요청을 처리하도록 할 수 있다. 이때는 다중 스레드로부터 안전해야 한다.



        
